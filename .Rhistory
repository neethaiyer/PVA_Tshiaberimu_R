<<<<<<< Updated upstream
plot(growthRates[,1:2])
abline(lm(growthRates[,2]~growthRates[,1]))
getwd()
setwd("/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/")
write.csv(growthRates, file="growthRates_LM2%.csv", row.names=F)
growthRates3 <- read.csv("growthRates_LM2%.csv")
growthRates2 <- read.csv("growthRates_LM2%.csv")
growthRates3 <- read.csv("growthRates_LM3%.csv")
growthRates2
growthRates3
plot(growthRates2[,1:2])
lines(growthRates3[,1:2])
plot(growthRates2[,1:2])
points(growthRates3[,1:2], col=2)
plot(growthRates2[,1:2])
points(growthRates3[,1:2], col=2)
abline(lm(growthRates2[,2]~growthRates2[,1]))
abline(lm(growthRates3[,2]~growthRates3[,1]), col=2)
setwd("/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/")
## If these directories do not exsit, run this:
dir.create("PVA_Output")
dir.create("PVA_Input")
dir.create("PVA_Output/Results")
dir.create("PVA_Output/LM_Projection")
dir.create("PVA_Output/IBM_Projection")
## Select the working directory for input files:
workingDir_Input <- "/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/PVA_Input/"
## Select the working directory for output files:
workingDir_Output <- "/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/PVA_Output/"
## DAMIEN !!!!! Your wd: ## Make sure to update as above!
## workingDir <- "~/Documents/git repositories/PVA_Tshiaberimu_R/"
## Source the functions used in simulations below:
source("1. Function Definitions.R")
####################################################################################
############################ READ LIFE HISTORY TABLE ###############################
####################################################################################
setwd(workingDir_Input)
## Your life history tables should have at least 3 columns: age, mortality rate, and fertility rate:
dat <- read.csv("Gorilla_LifeTables.csv")
dat$fertilityrate_2percent <- dat[,3]*.786
## fertility rates multiplied by factor less than 1 to get eigen values of 1.01 which corresponds to a 1% growth rate
dat$fertilityrate_1percent <- dat[,3]*.643
## fertility rates multiplied by factor less than 1 to get eigen values of 1.02 which corresponds to a 2% growth rate
##################################################################
############## Create an object that selects the LM ##############
##################################################################
selectLM <- read.csv("LeslieMatrix_MTN_2%.csv")
###############################################################################
############## SET THE INITIAL CONDITIONS OF THE LM & IBM MODELS ##############
###############################################################################
## Reintroduction Scenarios:
ReintroScenario <- read.csv("ReintroductionScenarios_LM.csv") ## csv file with Reintroduction Scenarios for LM
## Leslie Matrix parameters:
mat <- as.matrix(selectLM) ## LM needs to be converted to matrix object!
## Time parameters:
nyears <- 100 ## Projection Period
nruns <- 1000 ## Number of simulations to run
timeunit <- 1/12 ## timestep for IBM
## Initial demographic parameters: survivorship, fertility, and weaning age
datX <- dat[,1:3] ## Subset appropriate life history columns: dat[,c(1,4:5)] for WLG, dat[,1:3] for MTN
## NOTE: this subsetting is needed because columns for dat are specified in FUNCTIONS 8 and 9
weaningAge <- 3.5 ## 4.5 for WLG, 3.5 for MTN
adultAge <- 8 ## 10 for WLG, 8 for MTN
temp <- pop_projection(tfinal=nyears, LM=mat, No=ReintroScenario[,11]) ## run the LM projection
Nfinal <- data.frame(ReintroScenario$age, temp[,51])
colnames(Nfinal) <- c("age","N")
sum(Nfinal$N) ## check if Nfinal is about the same as Nfinal_expected for the required lambda value
Nfinal_expected <- 1.032^50*30 ## Nfinal_expected = lambda^t*No (lambda for 3% = 1.032)
N_random <- rep(Nfinal$age, round(Nfinal$N)) ## create vector with individuals and their ages
N_random <- sample(N_random, size=100, replace = FALSE, prob = NULL) ## randomly sample 100 individuals in each age class
N_random <- data.frame(subset(N_random, N_random>weaningAge)) ## remove individuals younger than weaning age
colnames(N_random) <- "TestScenario"
growthRates <- data.frame(alpha_value = NA,
growth_rate = NA, lambda = NA)
## run the IBM projection
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.10 ## set alpha value
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
=======
>>>>>>> Stashed changes
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
<<<<<<< Updated upstream
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/10)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[4,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
as.numeric(res[840,])
as.numeric(res[nrow(res),])
=======
>>>>>>> Stashed changes
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.28 ## set alpha value
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/10)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
<<<<<<< Updated upstream
growthRates[1,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
=======
growthRates[14,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates
## check
>>>>>>> Stashed changes
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
growthRates1 <- read.csv("growthRates_LM2%_100yrs.csv")
growthRates2 <- read.csv("growthRates_LM2%.csv")
growthRates3 <- read.csv("growthRates_LM3%.csv")
plot(growthRates1[,1:2])
points(growthRates3[,1:2], col=2)
plot(growthRates2[,1:2], col=4)
abline(lm(growthRates2[,2]~growthRates2[,1]))
abline(lm(growthRates3[,2]~growthRates3[,1]), col=2)
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
<<<<<<< Updated upstream
alpha <- 0.50 ## set alpha value
=======
alpha <- 0.29 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/10)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
<<<<<<< Updated upstream
growthRates[2,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
nrow(res)-840
nrow(res)
logLambda <- mean((1/(nrow(res)-840))*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[2,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
alpha <- c(0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5,0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,0.96,0.98,0.99) ## set alpha value
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.55 ## set alpha value
=======
growthRates[15,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates
## check
growthRates <- growthRates[order(-growthRates$alpha_value),]
## change row to 15 for next alpha
growthRates
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.34 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/(nrow(res)-840))*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
<<<<<<< Updated upstream
growthRates[1,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
=======
growthRates[16,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates
## check
>>>>>>> Stashed changes
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
<<<<<<< Updated upstream
alpha <- 0.40 ## set alpha value
=======
alpha <- 0.35 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/(nrow(res)-840))*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
<<<<<<< Updated upstream
growthRates[3,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
=======
growthRates[16,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
>>>>>>> Stashed changes
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
<<<<<<< Updated upstream
alpha <- 0.45 ## set alpha value
=======
alpha <- 0.35 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/(nrow(res)-840))*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
<<<<<<< Updated upstream
growthRates[4,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.80 ## set alpha value
=======
growthRates[17,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
getwd()
,
write.csv(growthRates, file=paste0("pva_projection_IBM","growthRates.csv"), row.names=F)
write.csv(growthRates, file=paste0("pva_projection_IBM/growthRates.csv"), row.names=F)
workingDir <- "/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/"
setwd(workingDir)
workingDir_Results <- ("/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/pva_extn_results/")
##workingDir <- "~/Documents/git repositories/PVA_Tshiaberimu_R/"
## Source the functions used in simulations below:
source("1. Function Definitions.R")
dat <- read.csv(paste0(workingDir, "Gorilla_LifeTables.csv"))
dat$fertilityrate_2percent <- dat[,3]*.786
## fertility rates multiplied by factor less than 1 to get eigen values of 1.01 which corresponds to a 1% growth rate
dat$fertilityrate_1percent <- dat[,3]*.643
## fertility rates multiplied by factor less than 1 to get eigen values of 1.02 which corresponds to a 2% growth rate
dat <- read.csv("Gorilla_LifeTables.csv")
dat$fertilityrate_2percent <- dat[,3]*.786
## fertility rates multiplied by factor less than 1 to get eigen values of 1.01 which corresponds to a 1% growth rate
dat$fertilityrate_1percent <- dat[,3]*.643
## fertility rates multiplied by factor less than 1 to get eigen values of 1.02 which corresponds to a 2% growth rate
leslieMatrix(lifetable=dat[,1:3], filename=paste0(workingDir,"LeslieMatrix_MTN_3%.csv"))
ReintroScenario <- read.csv("ReintroductionScenarios_LM.csv") ## csv file with Reintroduction Scenarios for LM
ReintroScenario_IBM <- read.csv("ReintroductionScenarios_IBM.csv") ## csv file with Reintroduction Scenarios for IBM
mat <- as.matrix(read.csv("LeslieMatrix_WLG.csv")) ## csv file with appropriate Leslie Matrix (needs to be converted to matrix object!)
nyears <- 50 ## Projection Period
nruns <- 1000 ## Number of simulations to run
timeunit <- 1/12 ## timestep for IBM
View(mat)
mat <- as.matrix(read.csv("LeslieMatrix_MTN_2%.csv")) ## csv file with appropriate Leslie Matrix (needs to be converted to matrix object!)
nyears <- 50 ## Projection Period
nruns <- 1000 ## Number of simulations to run
timeunit <- 1/12 ## timestep for IBM
datX <- dat[,1:3] ## Subset appropriate life history columns: dat[,c(1,4:5)] for WLG, dat[,1:3] for MTN
## NOTE: this subsetting is needed because columns for dat are specified in FUNCTIONS 8 and 9
weaningAge <- 3.5 ## 4.5 for WLG, 3.5 for MTN
adultAge <- 8 ## 10 for WLG, 8 for MTN
alpha <- 0.35 ## function of the fertility rate
initalConditions <- convertToList(scenario = ReintroScenario_IBM, adultAge=adultAge, weaningAge=weaningAge)
projectPop <- for(i in 2:ncol(ReintroScenario)){
No <- ReintroScenario[,i] ## Get the reintroduction scenario
N <- pop_projection(tfinal=nyears, LM=mat, No=No) ## Apply pop_projection function to No for this scenario
scenario <- strsplit(colnames(ReintroScenario)[i], "_")[[1]][2] ## Get the last element of the column name for each reintroducion scenario
det <- assign(paste0("N_projected_det", scenario), apply(N,2,sum))  ## The assign function takes a variable name as a character string and assigns a value to it. In this case, the values are N at each time step of the projection
write.csv(det, file=paste0("pva_projection_LM/LM_Det_Scenario", i-1, ".csv"), row.names=F)
}
## Second, use the stochastic function:
temp <- matrix(0, nrow=nyears+1, ncol=nruns)
## create an empty matrix that will save the number of individuals for each year of the projection for each run of the LM projection
for(j in 1:length(ReintroScenario)){
for(i in 1:nruns) {
temp[1:(nyears+1),i] <- apply(stoch_projection(tfinal=nyears, LM=mat, No=ReintroScenario[,j+1]),2,sum)
}
write.csv(temp, file=paste0("pva_projection_LM/LM_Scenario", j,".csv"), row.names=F)
}
getwd()
View(ReintroScenario)
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
<<<<<<< Updated upstream
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/(nrow(res)-840))*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[5,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.85 ## set alpha value
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/(nrow(res)-840))*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[6,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.90 ## set alpha value
=======
write.csv(res, file=paste0("pva_projection_IBM/IBM_Scenario", j,".csv"), row.names=F)
}
workingDir <- "~/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/"
setwd(workingDir)
source("1. Function Definitions.R")
#### Rerun deterministic projection with No=30, t= 50 years
## Reintroduction Scenarios:
ReintroScenario <- read.csv(paste0(workingDir, "ReintroductionScenarios_LM.csv")) ## csv file with Reintroduction Scenarios for LM
mat <- as.matrix(read.csv(paste0(workingDir, "LeslieMatrix_MTN_2%.csv"))) ## csv file with appropriate Leslie Matrix (needs to be converted to matrix object!)
dat <- read.csv(paste0(workingDir, "Gorilla_LifeTables.csv"))
dat$fertilityrate_2percent <- dat[,3]*.786
## fertility rates multiplied by factor less than 1 to get eigen values of 1.01 which corresponds to a 1% growth rate
dat$fertilityrate_1percent <- dat[,3]*.643
## fertility rates multiplied by factor less than 1 to get eigen values of 1.02 which corresponds to a 2% growth rate
nyears <- 50 ## Projection Period
nruns <- 1000 ## Number of simulations to run
## Make sure your current working directory is the main folder:
setwd("/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/")
## If these directories do not exsit, run this:
dir.create("PVA_Output")
dir.create("PVA_Input")
dir.create("PVA_Output/Results")
dir.create("PVA_Output/LM_Projection")
dir.create("PVA_Output/IBM_Projection")
## Select the working directory for input files:
workingDir_Input <- "/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/PVA_Input/"
## Select the working directory for output files:
workingDir_Output <- "/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/PVA_Output/"
## DAMIEN !!!!! Your wd: ## Make sure to update as above!
## workingDir <- "~/Documents/git repositories/PVA_Tshiaberimu_R/"
## Source the functions used in simulations below:
source("1. Function Definitions.R")
setwd("/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/")
## If these directories do not exsit, run this:
dir.create("PVA_Output")
dir.create("PVA_Input")
dir.create("PVA_Output/Results")
dir.create("PVA_Output/LM_Projection")
dir.create("PVA_Output/IBM_Projection")
## Select the working directory for input files:
workingDir_Input <- "/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/PVA_Input/"
## Select the working directory for output files:
workingDir_Output <- "/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/PVA_Output/"
## DAMIEN !!!!! Your wd: ## Make sure to update as above!
## workingDir <- "~/Documents/git repositories/PVA_Tshiaberimu_R/"
## Source the functions used in simulations below:
source("1. Function Definitions.R")
setwd(workingDir_Input)
## Your life history tables should have at least 3 columns: age, mortality rate, and fertility rate:
dat <- read.csv("Gorilla_LifeTables.csv")
dat$fertilityrate_2percent <- dat[,3]*.786
## fertility rates multiplied by factor less than 1 to get eigen values of 1.01 which corresponds to a 1% growth rate
dat$fertilityrate_1percent <- dat[,3]*.643
## fertility rates multiplied by factor less than 1 to get eigen values of 1.02 which corresponds to a 2% growth rate
selectLM <- read.csv("LeslieMatrix_MTN_2%.csv")
###############################################################################
############## SET THE INITIAL CONDITIONS OF THE LM & IBM MODELS ##############
###############################################################################
## Reintroduction Scenarios:
ReintroScenario <- read.csv("ReintroductionScenarios_LM.csv") ## csv file with Reintroduction Scenarios for LM
## Leslie Matrix parameters:
mat <- as.matrix(selectLM) ## LM needs to be converted to matrix object!
## Time parameters:
nyears <- 100 ## Projection Period
nruns <- 1000 ## Number of simulations to run
timeunit <- 1/12 ## timestep for IBM
## Initial demographic parameters: survivorship, fertility, and weaning age
datX <- dat[,1:3] ## Subset appropriate life history columns: dat[,c(1,4:5)] for WLG, dat[,1:3] for MTN
## NOTE: this subsetting is needed because columns for dat are specified in FUNCTIONS 8 and 9
weaningAge <- 3.5 ## 4.5 for WLG, 3.5 for MTN
adultAge <- 8 ## 10 for WLG, 8 for MTN
temp <- pop_projection(tfinal=nyears, LM=mat, No=ReintroScenario[,11]) ## run the LM projection
Nfinal <- data.frame(ReintroScenario$age, temp[,51])
colnames(Nfinal) <- c("age","N")
sum(Nfinal$N) ## check if Nfinal is about the same as Nfinal_expected for the required lambda value
Nfinal_expected <- 1.032^50*30 ## Nfinal_expected = lambda^t*No (lambda for 3% = 1.032)
N_random <- rep(Nfinal$age, round(Nfinal$N)) ## create vector with individuals and their ages
N_random <- sample(N_random, size=100, replace = FALSE, prob = NULL) ## randomly sample 100 individuals in each age class
N_random <- data.frame(subset(N_random, N_random>weaningAge)) ## remove individuals younger than weaning age
colnames(N_random) <- "TestScenario"
growthRates <- data.frame(alpha_value = NA,
growth_rate = NA, lambda = NA)
## run the IBM projection
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
growthRates2 <- read.csv("growthRates_LM2%.csv")
growthRates3 <- read.csv("growthRates_LM3%.csv")
plot(growthRates2[,1:2])
points(growthRates3[,1:2], col=2)
abline(lm(growthRates2[,2]~growthRates2[,1]))
abline(lm(growthRates3[,2]~growthRates3[,1]), col=2)
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.75 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
<<<<<<< Updated upstream
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/(nrow(res)-840))*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[7,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
nruns <- 10
alpha <- 0.30 ## set alpha value
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/(nrow(res)-840))*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[8,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.25 ## set alpha value
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/(nrow(res)-840))*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[9,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
=======
startPop <- as.numeric(res[480,])
logLambda <- mean((1/10)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[13,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
write.csv(growthRates, file="growthRates_LM2%_100yrs.csv", row.names=F)
70*12
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/10)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[1,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
growthRates <- data.frame(alpha_value = NA,
growth_rate = NA, lambda = NA)
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/10)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[1,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
>>>>>>> Stashed changes
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
<<<<<<< Updated upstream
alpha <- 0.35 ## set alpha value
=======
alpha <- 0.70 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
<<<<<<< Updated upstream
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
logLambda <- mean((1/(nrow(res)-840))*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[10,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
write.csv(growthRates, file="growthRates_LM2%_100yrs.csv", row.names=F)
## Make sure your current working directory is the main folder:
setwd("/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/")
growthRates1 <- read.csv("growthRates_LM2%_100yrs.csv")
growthRates2 <- read.csv("growthRates_LM2%.csv")
growthRates3 <- read.csv("growthRates_LM3%.csv")
plot(growthRates1[,1:2])
points(growthRates3[,1:2], col=2)
plot(growthRates2[,1:2], col=4)
abline(lm(growthRates2[,2]~growthRates2[,1]))
abline(lm(growthRates3[,2]~growthRates3[,1]), col=2)
plot(growthRates1[,1:2])
plot(growthRates2[,1:2], col=4)
points(growthRates3[,1:2], col=2)
plot(growthRates1[,1:2])
points(growthRates3[,1:2], col=2)
View(growthRates1)
points(growthRates3[,1:2], col=2)
points(growthRates2[,1:2], col=4)
View(growthRates2)
nrow(res)-840
mean((1/30)*log(finalPop/startPop))
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.30 ## set alpha value
=======
growthRates <- data.frame(alpha_value = NA,
growth_rate = NA, lambda = NA)
## run the IBM projection
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.70 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
<<<<<<< Updated upstream
plot(growthRates3[,1:2], col=2)
points(growthRates2[,1:2], col=4)
abline(lm(growthRates2[,2]~growthRates2[,1]))
abline(lm(growthRates3[,2]~growthRates3[,1]), col=2)
plot(growthRates3[,1:2], col=2)
points(growthRates2[,1:2], col=4)
points(growthRates1[,1:2])
abline(lm(growthRates2[,2]~growthRates2[,1]), col=4)
abline(lm(growthRates3[,2]~growthRates3[,1]), col=2)
plot(growthRates3[,1:2], col=2)
points(growthRates2[,1:2], col=4)
abline(lm(growthRates2[,2]~growthRates2[,1]), col=4)
abline(lm(growthRates3[,2]~growthRates3[,1]), col=2)
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.30 ## set alpha value
=======
## Source the functions used in simulations below:
source("1. Function Definitions.R")
setwd("/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/")
## If these directories do not exsit, run this:
dir.create("PVA_Output")
dir.create("PVA_Input")
dir.create("PVA_Output/Results")
dir.create("PVA_Output/LM_Projection")
dir.create("PVA_Output/IBM_Projection")
## Select the working directory for input files:
workingDir_Input <- "/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/PVA_Input/"
## Select the working directory for output files:
workingDir_Output <- "/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/PVA_Output/"
## DAMIEN !!!!! Your wd: ## Make sure to update as above!
## workingDir <- "~/Documents/git repositories/PVA_Tshiaberimu_R/"
## Source the functions used in simulations below:
source("1. Function Definitions.R")
setwd(workingDir_Input)
## Your life history tables should have at least 3 columns: age, mortality rate, and fertility rate:
dat <- read.csv("Gorilla_LifeTables.csv")
dat$fertilityrate_2percent <- dat[,3]*.786
## fertility rates multiplied by factor less than 1 to get eigen values of 1.01 which corresponds to a 1% growth rate
dat$fertilityrate_1percent <- dat[,3]*.643
## fertility rates multiplied by factor less than 1 to get eigen values of 1.02 which corresponds to a 2% growth rate
##################################################################
############## Create an object that selects the LM ##############
##################################################################
selectLM <- read.csv("LeslieMatrix_MTN_2%.csv")
###############################################################################
############## SET THE INITIAL CONDITIONS OF THE LM & IBM MODELS ##############
###############################################################################
## Reintroduction Scenarios:
ReintroScenario <- read.csv("ReintroductionScenarios_LM.csv") ## csv file with Reintroduction Scenarios for LM
## Leslie Matrix parameters:
mat <- as.matrix(selectLM) ## LM needs to be converted to matrix object!
## Time parameters:
nyears <- 100 ## Projection Period
nruns <- 1000 ## Number of simulations to run
timeunit <- 1/12 ## timestep for IBM
## Initial demographic parameters: survivorship, fertility, and weaning age
datX <- dat[,1:3] ## Subset appropriate life history columns: dat[,c(1,4:5)] for WLG, dat[,1:3] for MTN
## NOTE: this subsetting is needed because columns for dat are specified in FUNCTIONS 8 and 9
weaningAge <- 3.5 ## 4.5 for WLG, 3.5 for MTN
adultAge <- 8 ## 10 for WLG, 8 for MTN
temp <- pop_projection(tfinal=nyears, LM=mat, No=ReintroScenario[,11]) ## run the LM projection
Nfinal <- data.frame(ReintroScenario$age, temp[,51])
colnames(Nfinal) <- c("age","N")
sum(Nfinal$N) ## check if Nfinal is about the same as Nfinal_expected for the required lambda value
N_random <- rep(Nfinal$age, round(Nfinal$N)) ## create vector with individuals and their ages
N_random <- sample(N_random, size=100, replace = FALSE, prob = NULL) ## randomly sample 100 individuals in each age class
N_random <- data.frame(subset(N_random, N_random>weaningAge)) ## remove individuals younger than weaning age
colnames(N_random) <- "TestScenario"
N_random
growthRates <- data.frame(alpha_value = NA,
growth_rate = NA, lambda = NA)
## run the IBM projection
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
alpha <- 0.70 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
<<<<<<< Updated upstream
logLambda <- mean((1/30)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[1,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
growthRates <- data.frame(alpha_value = NA,
growth_rate = NA, lambda = NA)
growthRates[1,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
=======
logLambda <- mean((1/10)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
lambda <- exp(logLambda)
growthRates[1,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
>>>>>>> Stashed changes
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
View(datX)
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
<<<<<<< Updated upstream
alpha <- 0.40 ## set alpha value
=======
alpha <- 0.75 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
<<<<<<< Updated upstream
logLambda <- mean((1/30)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
=======
logLambda <- mean((1/10)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
>>>>>>> Stashed changes
lambda <- exp(logLambda)
growthRates[2,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
growthRates1 <- read.csv("growthRates_LM2%_100yrs.csv")
growthRates2 <- read.csv("growthRates_LM2%.csv")
growthRates3 <- read.csv("growthRates_LM3%.csv")
plot(growthRates3[,1:2], col=2)
points(growthRates2[,1:2], col=4)
points(growthRates1[,1:2])
abline(lm(growthRates2[,2]~growthRates2[,1]), col=4)
abline(lm(growthRates3[,2]~growthRates3[,1]), col=2)
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
<<<<<<< Updated upstream
alpha <- 0.50 ## set alpha value
=======
alpha <- 0.80 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
<<<<<<< Updated upstream
logLambda <- mean((1/30)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
=======
logLambda <- mean((1/10)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
>>>>>>> Stashed changes
lambda <- exp(logLambda)
growthRates[3,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
View(growthRates1)
View(growthRates1)
setwd("/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/")
write.csv(growthRates, file="growthRates_LM2%_100yrs_FINAL.csv", row.names=F)
growthRates1 <- read.csv("growthRates_LM2%_100yrs_FINAL.csv")
growthRates2 <- read.csv("growthRates_LM2%.csv")
growthRates3 <- read.csv("growthRates_LM3%.csv")
plot(growthRates3[,1:2], col=2)
points(growthRates2[,1:2], col=4)
abline(lm(growthRates2[,2]~growthRates2[,1]), col=4)
abline(lm(growthRates3[,2]~growthRates3[,1]), col=2)
points(growthRates1[,1:2])
abline(lm(growthRates1[,2]~growthRates1[,1]))
timeunit<-1/12
initalConditions <- convertToList(scenario = N_random, adultAge=adultAge, weaningAge=weaningAge) ## define initial conditions based on ages of females randomly sampled earlier in N_random
nruns <- 10
<<<<<<< Updated upstream
alpha <- 0.60 ## set alpha value
=======
alpha <- 0.85 ## set alpha value
>>>>>>> Stashed changes
res <- matrix(0, nrow=trunc(nyears/timeunit)+1, ncol=nruns)
for(j in 1:length(initalConditions)){
for(i in 1:nruns){
print(i)
abmDataLog <- simTshia(ages0 = initalConditions[[j]][,1], status0 = initalConditions[[j]][,2], time0 = initalConditions[[j]][,3], nyears=nyears, alpha=alpha, timeunit=timeunit, verbose=F)
nindiv <- tapply(abmDataLog$status,abmDataLog$timestep, function(v) length(v)+rbinom(1, sum(v=="L"), .5))##we're adding the unweaned females
res[1:length(nindiv),i] <- nindiv
}
}
finalPop <- as.numeric(res[nrow(res),])
startPop <- as.numeric(res[840,])
##startPop <- rep(100,nruns) ## if using No at t=0
<<<<<<< Updated upstream
logLambda <- mean((1/30)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
=======
logLambda <- mean((1/10)*log(finalPop/startPop)) ## nyears for the census time period, loglambda = 1/timeperiod*log(Ntfinal)/Nt0
>>>>>>> Stashed changes
lambda <- exp(logLambda)
growthRates[4,1:3] <- c(alpha, round(logLambda, digits=3), round(lambda, digits=3))
growthRates <- growthRates[order(-growthRates$alpha_value),]
growthRates
<<<<<<< Updated upstream
setwd("/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/")
write.csv(growthRates, file="growthRates_LM2%_100yrs_FINAL.csv", row.names=F)
growthRates1 <- read.csv("growthRates_LM2%_100yrs_FINAL.csv")
growthRates2 <- read.csv("growthRates_LM2%.csv")
growthRates3 <- read.csv("growthRates_LM3%.csv")
plot(growthRates3[,1:2], col=2)
points(growthRates2[,1:2], col=4)
points(growthRates1[,1:2])
abline(lm(growthRates3[,2]~growthRates3[,1]), col=2)
abline(lm(growthRates2[,2]~growthRates2[,1]), col=4)
abline(lm(growthRates1[,2]~growthRates1[,1]))
=======
write.csv(growthRates, file="growthRates_LM2%_100yrs.csv", row.names=F)
growthRates3 <- read.csv("growthRates_LM3%.csv")
## Make sure your current working directory is the main folder:
setwd("/Users/neethaiyer/Desktop/PVA_Tshiaberimu_R/")
## Examine how alpha and growth rate vary:
growthRates2 <- read.csv("growthRates_LM2%.csv")
growthRates3 <- read.csv("growthRates_LM3%.csv")
## Examine how alpha and growth rate vary:
growthRates1 <- read.csv("growthRates_LM2%_100years.csv")
## Examine how alpha and growth rate vary:
growthRates1 <- read.csv("growthRates_LM2%_100years.csv")
## Examine how alpha and growth rate vary:
growthRates1 <- read.csv("growthRates_LM2%_100yrs.csv")
plot(growthRates2[,1:2])
points(growthRates3[,1:2], col=2)
points(growthRates1[,1:2], col=3, pch=2)
View(growthRates1)
points(growthRates1[,1:2], col=4, pch=2)
points(growthRates1[,1:2], col=4)
plot(growthRates2[,1:2])
points(growthRates1[,1:2], col=4)
plot(growthRates1[,1:2], col=4)
>>>>>>> Stashed changes
